# Формат `Availability.rules` для расписания "Каждый второй понедельник и каждый четверг"

## 1. Анализ задачи

Расписание "каждый второй понедельник и каждый четверг" требует описания двух разных повторяющихся правил:
- **Каждый второй понедельник**: Повторяется каждые две недели по понедельникам (например, 6 января, 20 января, 3 февраля 2025).
- **Каждый четверг**: Повторяется еженедельно по четвергам (например, 2 января, 9 января, 16 января 2025).

### 1.1. Подход к формированию
- **Поле `intervals`**:
  - Задаёт временные слоты (например, 8:00–20:00) и дни недели (`days_of_week`).
  - Может включать оба дня (`MON`, `THU`), но не описывает интервалы повторения (каждые 2 недели для понедельников).
- **Поле `recurrence_rule`**:
  - Описывает повторяющиеся правила (еженедельные, с интервалом).
  - Позволяет задать разные частоты для понедельников (`interval: 2`) и четвергов (`interval: 1`).
- **Проблема**:
  - Одно `recurrence_rule` не может одновременно описать "каждые 2 недели по понедельникам" и "каждую неделю по четвергам", так как `interval` и `byweekday` применяются ко всем дням.
- **Решение**:
  - Разделить расписание на **две записи `Availability`**:
    - Одна для понедельников (каждые 2 недели).
    - Одна для четвергов (каждую неделю).
  - Альтернативно: Использовать несколько `intervals` с уточнением в `recurrence_rule`, но это менее предпочтительно из-за сложности валидации.

### 1.2. Выбранный подход
- Создать **две записи `Availability`** в базе данных (с разными `id`):
  - Первая: Для понедельников с `recurrence_rule.interval: 2`.
  - Вторая: Для четвергов с `recurrence_rule.interval: 1`.
- Объединить их при валидации, чтобы проверить доступность времени.
- Это упрощает:
  - Хранение в JSONB (каждая запись имеет чёткое `recurrence_rule`).
  - Валидацию (каждая запись проверяется отдельно).
  - Совместимость с `rrule` (каждое правило маппится на отдельный `RRule`).

---

## 2. Формат `Availability.rules`

Для расписания "каждый второй понедельник с 8:00 до 20:00 и каждый четверг с 8:00 до 20:00" создаются две записи `Availability`.

### 2.1. Запись 1: Каждый второй понедельник
- **Контекст**: `SPECIALIST` (или `VENUE`, `ROOM` в зависимости от сущности).
- **Описание**: Слоты с 8:00 до 20:00 по понедельникам, повторяющиеся каждые 2 недели, начиная с 6 января 2025, до 31 декабря 2025.

```json
{
  "context": "SPECIALIST",
  "organizationId": "uuid2",
  "intervals": [
    {
      "start_time": "08:00",
      "end_time": "20:00",
      "days_of_week": ["MON"],
      "valid_from": "2025-01-06",
      "valid_until": "2025-12-31"
    }
  ],
  "exceptions": [],
  "recurrence_rule": {
    "frequency": "WEEKLY",
    "interval": 2,
    "until": "2025-12-31",
    "byweekday": ["MO"]
  }
}
```

- **Пояснения**:
  - `intervals`: Указывает время (8:00–20:00) и день (`MON`).
  - `valid_from`: Начинается с 6 января 2025 (первый понедельник цикла).
  - `recurrence_rule`:
    - `frequency: "WEEKLY"`: Еженедельное повторение.
    - `interval: 2`: Каждые 2 недели.
    - `byweekday: ["MO"]`: Только понедельники.
    - `until: "2025-12-31"`: Конец расписания.
  - Итог: Слоты 6 января, 20 января, 3 февраля, и т.д.

### 2.2. Запись 2: Каждый четверг
- **Контекст**: `SPECIALIST` (или `VENUE`, `ROOM`).
- **Описание**: Слоты с 8:00 до 20:00 по четвергам, повторяющиеся каждую неделю, начиная с 2 января 2025, до 31 декабря 2025.

```json
{
  "context": "SPECIALIST",
  "organizationId": "uuid2",
  "intervals": [
    {
      "start_time": "08:00",
      "end_time": "20:00",
      "days_of_week": ["THU"],
      "valid_from": "2025-01-02",
      "valid_until": "2025-12-31"
    }
  ],
  "exceptions": [],
  "recurrence_rule": {
    "frequency": "WEEKLY",
    "interval": 1,
    "until": "2025-12-31",
    "byweekday": ["TH"]
  }
}
```

- **Пояснения**:
  - `intervals`: Указывает время (8:00–20:00) и день (`THU`).
  - `valid_from`: Начинается с 2 января 2025 (первый четверг).
  - `recurrence_rule`:
    - `frequency: "WEEKLY"`: Еженедельное повторение.
    - `interval: 1`: Каждую неделю.
    - `byweekday: ["TH"]`: Только четверги.
    - `until: "2025-12-31"`: Конец расписания.
  - Итог: Слоты 2 января, 9 января, 16 января, и т.д.

### 2.3. Альтернативный подход (одна запись)
- Можно попытаться объединить оба правила в одной записи, используя несколько `intervals`:

  ```json
  {
    "context": "SPECIALIST",
    "organizationId": "uuid2",
    "intervals": [
      {
        "start_time": "08:00",
        "end_time": "20:00",
        "days_of_week": ["MON"],
        "valid_from": "2025-01-06",
        "valid_until": "2025-12-31"
      },
      {
        "start_time": "08:00",
        "end_time": "20:00",
        "days_of_week": ["THU"],
        "valid_from": "2025-01-02",
        "valid_until": "2025-12-31"
      }
    ],
    "exceptions": [],
    "recurrence_rule": {
      "frequency": "WEEKLY",
      "interval": 1,
      "until": "2025-12-31",
      "byweekday": ["MO", "TH"]
    }
  }
  ```

- **Проблемы**:
  - `interval: 1` применяется ко всем дням, что не соответствует "каждый второй понедельник".
  - Требуется дополнительная логика валидации, чтобы интерпретировать `interval: 2` для понедельников отдельно.
  - Усложняет маппинг на `rrule` и запросы к JSONB.
- **Вывод**: Две отдельные записи предпочтительнее, так как они:
  - Чётко разделяют правила.
  - Упрощают валидацию и индексацию.
  - Соответствуют `rrule` без дополнительных условий.

---

## 3. Использование в каскадной валидации

### 3.1. Роль в валидации
- При валидации бронирования (`Booking`) или события (`Event`) проверяется, попадает ли запрашиваемое время в слоты, определённые `recurrence_rule` и `intervals`, с учётом приоритетов (`Venue` > `Room` > `Specialist`).
- Для расписания с двумя записями `Availability` (понедельники и четверги):
  - Найти все записи `Availability` для сущности (например, `specialistId`, `organizationId`).
  - Проверить каждую запись отдельно.

### 3.2. Пример валидации
- **Входные данные**:
  - `specialistId`: `"uuid1"`.
  - `organizationId`: `"uuid2"`.
  - `venueId`: `"uuid3"`.
  - `roomId`: `"uuid4"`.
  - `startTime`: `"2025-01-13T09:30:00Z"` (понедельник, второй в году).
  - `endTime`: `"2025-01-13T10:30:00Z"`.
- **Данные `Availability`**:
  - Запись 1 (понедельники, каждый второй):

    ```json
    {
      "context": "SPECIALIST",
      "intervals": [
        {
          "start_time": "08:00",
          "end_time": "20:00",
          "days_of_week": ["MON"],
          "valid_from": "2025-01-06"
        }
      ],
      "recurrence_rule": {
        "frequency": "WEEKLY",
        "interval": 2,
        "byweekday": ["MO"]
      }
    }
    ```

  - Запись 2 (четверги, каждый):

    ```json
    {
      "context": "SPECIALIST",
      "intervals": [
        {
          "start_time": "08:00",
          "end_time": "20:00",
          "days_of_week": ["THU"],
          "valid_from": "2025-01-02"
        }
      ],
      "recurrence_rule": {
        "frequency": "WEEKLY",
        "interval": 1,
        "byweekday": ["TH"]
      }
    }
    ```

- **Процесс валидации** (для Specialist):
  1. Найти все `Availability` для `specialistId: "uuid1"`, `organizationId: "uuid2"`.
  2. Проверить запись 1 (понедельники):
     - `recurrence_rule`: Каждый второй понедельник с 6 января → 13 января (второй понедельник) валидно.
     - `intervals`: 9:30–10:30 в 8:00–20:00 → `true`.
  3. Проверить запись 2 (четверги):
     - `recurrence_rule`: Каждый четверг → 13 января (понедельник) невалидно.
  4. Итог: Время валидно, так как запись 1 (понедельники) подходит.
- **Примечание**:
  - Валидация продолжается для `Venue` и `Room` (по приоритетам).
  - Если `Venue` или `Room` недоступны, возвращается ошибка.

### 3.3. Учёт приоритетов
- **Venue**: Проверяется первым. Если `recurrence_rule` Venue не включает 13 января, валидация завершается.
- **Room**: Проверяются `Event` и `Availability` (если есть `recurrence_rule`).
- **Specialist**: Проверяется последним, с учётом двух записей `Availability`.

---

## 4. Рекомендации

### 4.1. Почему две записи
- **Чёткость**: Каждая запись описывает одно правило (`interval: 2` для понедельников, `interval: 1` для четвергов).
- **Совместимость с `rrule`**: Легко маппится на два отдельных `RRule` объекта.
- **Индексация**: Упрощает запросы к JSONB (например, `rules->'recurrence_rule'->'byweekday'`).
- **Валидация**: Легче проверять каждую запись отдельно.

### 4.2. Оптимизация
- **Индексы JSONB**:
  - Создать GIN-индексы для `rules->'recurrence_rule'->'byweekday'` и `rules->'intervals'->'days_of_week'`.
- **Минимизация данных**:
  - Если `recurrence_rule.byweekday` совпадает с `intervals.days_of_week`, можно опустить `days_of_week`.

### 4.3. Альтернативы
- **Одна запись с подправками**:
  - Использовать `recurrence_rule` для четвергов и отдельное поле для понедельников:

    ```json
    {
      "intervals": [
        {
          "start_time": "08:00",
          "end_time": "20:00",
          "days_of_week": ["THU"]
        }
      ],
      "recurrence_rule": {
        "frequency": "WEEKLY",
        "interval": 1,
        "byweekday": ["TH"]
      },
      "custom_rules": {
        "mondays": {
          "frequency": "WEEKLY",
          "interval": 2,
          "byweekday": ["MO"],
          "start_time": "08:00",
          "end_time": "20:00"
        }
      }
    }
    ```

  - Недостаток: Нестандартное поле `custom_rules` усложняет валидацию и `rrule`.

- **Вывод**: Две записи — оптимальный выбор для простоты и масштабируемости.

### 4.4. Интеграция
- **TypeScript-тип** (в `shared/types/availability.ts`):
  - Формат `recurrence_rule` уже поддерживает `byweekday` и `interval`, изменений не требуется.
- **API**:
  - Эндпоинт `POST /availability` создаёт две записи для одного `specialistId` или `venueId`.
  - Эндпоинт `GET /availability/:specialistId` возвращает обе записи.
- **Валидация**:
  - Найти все `Availability` для сущности и проверить `recurrence_rule` каждой записи.

---

## 5. Пример полного расписания

### 5.1. Две записи `Availability`
- **Запись 1 (понедельники)**:

  ```json
  {
    "context": "SPECIALIST",
    "organizationId": "uuid2",
    "intervals": [
      {
        "start_time": "08:00",
        "end_time": "20:00",
        "days_of_week": ["MON"],
        "valid_from": "2025-01-06",
        "valid_until": "2025-12-31"
      }
    ],
    "exceptions": [
      {
        "date": "2025-07-07",
        "status": "CLOSED"
      }
    ],
    "recurrence_rule": {
      "frequency": "WEEKLY",
      "interval": 2,
      "until": "2025-12-31",
      "byweekday": ["MO"]
    }
  }
  ```

- **Запись 2 (четверги)**:

  ```json
  {
    "context": "SPECIALIST",
    "organizationId": "uuid2",
    "intervals": [
      {
        "start_time": "08:00",
        "end_time": "20:00",
        "days_of_week": ["THU"],
        "valid_from": "2025-01-02",
        "valid_until": "2025-12-31"
      }
    ],
    "exceptions": [],
    "recurrence_rule": {
      "frequency": "WEEKLY",
      "interval": 1,
      "until": "2025-12-31",
      "byweekday": ["TH"]
    }
  }
  ```

### 5.2. Итоговое расписание
- **Понедельники**: 6 января, 20 января, 3 февраля, ..., с 8:00 до 20:00 (кроме 7 июля — закрыто).
- **Четверги**: 2 января, 9 января, 16 января, ..., с 8:00 до 20:00.
- **Валидация**:
  - Для `startTime: "2025-01-13T09:00:00Z"` (понедельник): Проверяется запись 1 → валидно.
  - Для `startTime: "2025-01-09T09:00:00Z"` (четверг): Проверяется запись 2 → валидно.

---

## 6. Заключение

Для расписания "каждый второй понедельник и каждый четверг" оптимально создать **две записи `Availability`**:
- **Понедельники**: `recurrence_rule` с `interval: 2`, `byweekday: ["MO"]`.
- **Четверги**: `recurrence_rule` с `interval: 1`, `byweekday: ["TH"]`.

Это обеспечивает:
- **Чёткость**: Каждое правило описано отдельно.
- **Совместимость**: Прямо маппится на `rrule`.
- **Простоту валидации**: Каждая запись проверяется независимо в каскадной валидации (`Venue` > `Room` > `Specialist`).

**Формат** использует `intervals` для времени и дней, а `recurrence_rule` для повторений, с учётом `valid_from` и `exceptions`. Если нужны уточнения (например, другие комбинации дней, формат для `VENUE`, или сценарии валидации), напишите, и я дополню!