# Бизнес-процессы сервиса расписания (с учётом ролей Владельца организации и Менеджера)

## 1. Общие принципы

- **Правила записи**:
  - Определяют график работы и доступные временные слоты для `Venue`, `Room`, `Specialist`.
  - Хранятся в `Availability.rules` (JSON Time Slots: `intervals`, `exceptions`, `recurrence_rule`).
  - Пример:
    ```json
    {
      "intervals": [
        {
          "start_time": "08:00",
          "end_time": "20:00",
          "days_of_week": ["MON", "TUE"],
          "valid_from": "2025-01-01"
        }
      ],
      "exceptions": [{ "date": "2025-07-04", "status": "CLOSED" }],
      "recurrence_rule": { "frequency": "WEEKLY", "interval": 1 }
    }
    ```
- **Шаблоны событий** (`EventTemplate`):
  - Создаются **Специалистом** для клиентских запросов (например, "Пробный урок") или личных целей (например, "Групповое занятие").
  - Содержат: название, длительность, тип доставки (`IN_PERSON`, `ONLINE`, `NONE`), необходимость подтверждения (`is_bookable`).
- **Записи** (`Booking`):
  - Создаются **Клиентом** через **Шаблоны событий** **Специалиста**.
  - Статусы: `PENDING` (ожидает назначения `roomId` или подтверждения), `CONFIRMED` (создано `Event`), `CANCELED`, `COMPLETED`.
- **События** (`Event`):
  - Создаются после подтверждения **Записи** или напрямую **Специалистом**.
  - Содержат: `room_id` (если требуется), `specialist_id`, `start_time`, `end_time`, `organization_id`.
- **Каскадная валидация**:
  - Проверяется доступность: `Venue` → `Room` → `Specialist`.
  - Пропускается для независимых специалистов (`organizationId: null` или `delivery: ONLINE/NONE`).

## 2. Роли и их функции

| **Роль**                                        | **Функции**                                                                                                                                                                                                                                                                                                                                                        | **Взаимодействие**                                                                                                                                 |
| ----------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Клиент** (`CLIENT`)                           | - Просматривает **Шаблоны событий** и **Правила записи** специалистов.<br>- Создаёт **Записи** через UI, выбирая шаблон, специалиста, время.<br>- Получает уведомления о статусе **Записи** (`PENDING`, `CONFIRMED`).                                                                                                                                              | - С **Специалистом** (через **Записи**).<br>- С **Менеджером** (через назначение `roomId`).                                                        |
| **Специалист** (`SPECIALIST`)                   | - Создаёт **Правила записи** (график, JSON Time Slots).<br>- Создаёт **Шаблоны событий** (клиентские или личные).<br>- Подтверждает **Записи** (если `is_bookable: false`).<br>- Создаёт **События** напрямую из любых **Шаблонов событий**.<br>- Может быть независимым (без `Venue`/`Room`) или работать в организации.                                          | - С **Клиентом** (подтверждение **Записей**).<br>- С **Менеджером** (назначение `roomId`).<br>- С **Владельцем** (ограничения на `Room`).          |
| **Менеджер** (`MANAGER`)                        | - Назначает `roomId` для **Записей** в `Venue`, которыми управляет (`ManagerProfile.managed_venues`).<br>- Проверяет доступность `Room` по **Правилам записи**.<br>- Подтверждает/отклоняет **Записи** (например, для групповых занятий).<br>- Управляет расписанием `Venue`/`Room` (добавляет исключения).<br>- Получает уведомления (`BOOKING_ROOM_ASSIGNMENT`). | - С **Клиентом** (через **Записи**).<br>- С **Специалистом** (уведомления, подтверждение).<br>- С **Владельцем** (получает доступ к `Venue`).      |
| **Владелец организации** (`ORGANIZATION_OWNER`) | - Создаёт и управляет `Organization`, `Venue`, `Room`.<br>- Назначает **Менеджеров** для `Venue`.<br>- Настраивает **Правила записи** для `Venue`.<br>- Ограничивает доступ **Специалистов** к `Room`.<br>- Просматривает аналитику по `Booking`/`Event`.<br>- Получает уведомления о критических событиях.                                                        | - С **Менеджером** (делегирует управление).<br>- С **Специалистом** (настройки, ограничения).<br>- Косвенно с **Клиентом** (через `Venue`/`Room`). |

## 3. Бизнес-процессы

### 3.1. Настройка организации и объектов

1. **Владелец организации**:
   - Создаёт `Organization` (например, "Йога-студия").
   - Добавляет `Venue` (например, "Студия на Ленина") и `Room` (например, "Зал 1").
   - Настраивает **Правила записи** для `Venue`:
     ```json
     {
       "intervals": [
         {
           "start_time": "09:00",
           "end_time": "21:00",
           "days_of_week": ["MON", "TUE", "WED"]
         }
       ]
     }
     ```
   - Назначает **Менеджера** для `Venue` (добавляет `Venue.id` в `ManagerProfile.managed_venues`).
   - Ограничивает доступ **Специалистов** (например, только йога-инструкторы используют "Зал 1").
2. **Менеджер**:
   - Получает доступ к `Venue` и `Room`.
   - Добавляет исключения в **Правила записи** (например, закрытие зала на ремонт).

### 3.2. Создание **Шаблонов событий**

1. **Специалист**:
   - Создаёт **Шаблоны событий**:
     - Клиентские (например, "Пробный урок йоги", `duration: 60min`, `is_bookable: true`).
     - Личные (например, "Групповая йога", `is_bookable: false`).
   - Указывает тип доставки (`IN_PERSON` требует `Venue`/`Room`, `ONLINE` — нет).
2. **Владелец организации** (если в организации):
   - Утверждает **Шаблоны событий** (например, проверяет соответствие бренду).
   - Может запретить использование определённых `Room` для шаблона.

### 3.3. Создание **Записи**

1. **Клиент**:
   - Просматривает **Шаблоны событий** и **Правила записи** **Специалиста** через UI.
   - Выбирает шаблон, специалиста, время (в пределах `Availability.rules`).
   - Создаёт **Запись** (`status: PENDING`, `eventId: null`).
2. **Система**:
   - Проверяет **Правила записи**:
     - Для `Venue` (если `Specialist.organizationId` не null).
     - Для `Specialist`.
     - Пропускает `Venue`/`Room`, если специалист независимый или `delivery: ONLINE/NONE`.
   - Если требуется `roomId`, уведомляет **Менеджера** (`BOOKING_ROOM_ASSIGNMENT`).
   - Если требуется подтверждение (`is_bookable: false`), уведомляет **Специалиста**.
3. **Менеджер** (если требуется `roomId`):
   - Получает уведомление о **Записи**.
   - Проверяет доступность `Room` в `managed_venues` по **Правилам записи**.
   - Назначает `roomId` через UI.
   - **Система**:
     - Создаёт `Event` (`room_id`, `specialist_id`, `start_time`, `end_time`).
     - Обновляет **Запись** (`eventId`, `status: PENDING` или `CONFIRMED`).
4. **Специалист** (если требуется подтверждение):
   - Получает уведомление о **Записи**.
   - Подтверждает или отклоняет через UI.
   - **Система**:
     - Если подтверждено, создаёт `Event` (если не создан **Менеджером**) и обновляет **Запись** (`status: CONFIRMED`).
     - Если отклонено, обновляет **Запись** (`status: CANCELED`).
5. **Клиент**:
   - Получает уведомление о статусе **Записи**.

### 3.4. Создание **События** напрямую

1. **Специалист**:
   - Выбирает **Шаблон событий** (свой или другой, если разрешено).
   - Указывает время, `roomId` (если требуется), тип доставки.
   - Создаёт **Событие** через UI.
2. **Система**:
   - Проверяет **Правила записи** (`Venue`, `Room`, `Specialist`).
   - Проверяет доступ к `Room` (установленный **Владельцем**).
   - Создаёт `Event` (`status: CONFIRMED`).
3. **Менеджер** (если требуется `roomId`):
   - Уведомляется, если **Специалист** запросил `Room` в организации.
   - Назначает `roomId` или подтверждает использование.

### 3.5. Уведомления

- **Типы**:
  - `BOOKING_ROOM_ASSIGNMENT`: **Менеджер** получает для назначения `roomId`.
  - `BOOKING_CONFIRMATION`: **Специалист** получает для подтверждения **Записи**.
  - `BOOKING_STATUS_UPDATE`: **Клиент** получает о статусе **Записи**.
  - `CRITICAL_EVENT`: **Владелец** получает о конфликтах или проблемах.
- **Каналы**: Email (AWS SES), SMS (Twilio), push (Firebase).
- **Пример**:
  ```json
  {
    "user_id": "UUID1",
    "type": "BOOKING_ROOM_ASSIGNMENT",
    "channel": "EMAIL",
    "content": { "booking_id": "UUID2", "venue_id": "UUID3" }
  }
  ```

## 4. Ограничения (таблица)

| **Правило**             | **Условие**                                                                                 | **Действие**                                      | **Результат**                                |
| ----------------------- | ------------------------------------------------------------------------------------------- | ------------------------------------------------- | -------------------------------------------- |
| **Валидация `Venue`**   | `Booking.start_time` в пределах `Availability.rules` для `Venue` (через `Organization.id`). | **Система** проверяет JSON Time Slots.            | Ошибка: "Venue закрыт".                      |
| **Назначение `roomId`** | Для **Специалиста** в организации требуется `roomId`.                                       | **Менеджер** выбирает `Room` из `managed_venues`. | **Запись** остаётся `PENDING` до назначения. |
| **Доступ к `Room`**     | **Специалист** использует `Room`, разрешённую **Владельцем**.                               | **Система** проверяет ограничения.                | Ошибка: "Доступ к комнате запрещён".         |
| **Подтверждение**       | Если `EventTemplate.is_bookable: false`, требуется подтверждение.                           | **Специалист** или **Менеджер** подтверждает.     | **Запись** остаётся `PENDING`.               |
| **Конфликты `Event`**   | `Event` не пересекается по времени с другими для `Room`/`Specialist`.                       | **Система** проверяет `Event`.                    | Ошибка: "Конфликт расписания".               |

## 5. Интеграция с API (OpenAPI)

```yaml
paths:
  /bookings:
    post:
      summary: Создать Запись (Клиент)
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                template_id: { type: string, format: uuid }
                specialist_id: { type: string, format: uuid }
                start_time: { type: string, format: date-time }
                end_time: { type: string, format: date-time }
      responses:
        '201':
          description: Запись создана (PENDING)
        '400':
          description: Ошибка валидации
  /bookings/{id}/assign-room:
    patch:
      summary: Назначить roomId (Менеджер)
      parameters:
        - name: id
          in: path
          required: true
          schema: { type: string, format: uuid }
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                roomId: { type: string, format: uuid }
      responses:
        '200':
          description: roomId назначен, Event создан
  /venues:
    post:
      summary: Создать Venue (Владелец организации)
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                organization_id: { type: string, format: uuid }
                name: { type: string }
                rules: { type: object }
      responses:
        '201':
          description: Venue создан
```

## 6. Пример валидации (псевдокод)

```typescript
async function createBooking(dto: CreateBookingDto) {
  const template = await db.getEventTemplate(dto.template_id);
  const specialist = await db.getSpecialistProfile(dto.specialist_id);

  // Валидация Venue (если в организации)
  if (specialist.organizationId) {
    const venue = await db.getVenueByOrganization(specialist.organizationId);
    if (!isAvailable(venue.availability, dto.start_time, dto.end_time)) {
      throw new Error('Venue закрыт');
    }
  }

  // Валидация Specialist
  if (!isAvailable(specialist.availability, dto.start_time, dto.end_time)) {
    throw new Error('Специалист занят');
  }

  // Создание Booking
  const booking = await db.createBooking({
    ...dto,
    status: 'PENDING',
    eventId: null,
  });

  // Уведомления
  if (specialist.organizationId && template.delivery === 'IN_PERSON') {
    const manager = await db.getManagerByVenue(venue.id);
    await notificationService.send(
      manager.id,
      'BOOKING_ROOM_ASSIGNMENT',
      booking,
    );
  } else if (!template.is_bookable) {
    await notificationService.send(
      specialist.id,
      'BOOKING_CONFIRMATION',
      booking,
    );
  }

  return booking;
}
```

## 7. Рекомендации

1. **Документирование**:
   - Храните описание процессов и ролей в Confluence или GitHub Wiki.
   - Обновите ER-диаграмму, добавив `Organization` и связи с `Venue`, `Room`.
2. **API**:
   - Реализуйте эндпоинты для **Владельца** (`POST /venues`, `POST /rooms`).
   - Добавьте RBAC для ограничения доступа (`@Roles('ORGANIZATION_OWNER')`).
3. **UI**:
   - Панель для **Владельца**: управление `Venue`, `Room`, назначение **Менеджеров**.
   - Панель для **Менеджера**: назначение `roomId`, управление расписанием `Venue`.
4. **Тестирование**:
   - Тесты для сценариев:
     - **Менеджер** назначает `roomId` только для `managed_venues`.
     - **Владелец** ограничивает доступ **Специалиста** к `Room`.
     - **Клиент** создаёт **Запись** только в доступные слоты.
5. **Масштабирование**:
   - Добавьте автоматическое предложение `Room` для **Менеджера** (на основе `Availability`).
   - Реализуйте аналитику для **Владельца** (дашборд с количеством `Booking`/`Event`).
